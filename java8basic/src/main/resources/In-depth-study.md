

Java 8对接口的改变：
   1.增加了default方法和static方法，这两种方法完全可以有方法体
   2.default方法属于实例，static方法属于类（接口）
   3.接口里面的静态方法不会被继承，静态变量会被继承下来
   4.如果一个类实现了多个接口，并且这些接口互相之间没有继承关系，可以存在相同的默认方法
     会报错，不相关默认值。如果多个接口有继承关系，默认方法会被子类接口覆盖。
   5.如果存在多个继承，并且有相同的默认方法，实现类可以通过特殊语法指定要访问哪个接口的方法。
     在实现类或者子接口中重写默认方法，在方法里面写：
     <接口>.super.<方法名>([参数])
   6.如果一个接口只有一个抽象方法（包括继承的），该接口是一个函数式接口
     函数式接口可以使用Lambda表达式实现。
   7.如果接口里面使用了FunctionalInterface注解限定接口里面只能有个抽象方法


函数式接口：
    当接口只有一个抽象方法的时候，就是函数式接口，可以使用注解强制限定接口只能有一个抽象方法
    注解：从java5开始引入注解，利用注解对字节码文件进行一些说明。
    @FunctionalInterface注解的作用是用于在编译告诉编译器改接口里只能有一个抽象方法。
    Lambda表达式只能针对函数式接口使用
    
    
接口里面的静态方法:
  从java8开始接口里面可以有静态方法，和普通类里面的静态方法类似，使用Static修饰，但是接口里面只能是public的
    
  public static <返回值><方法名>(参数列表)
  {
      方法体
  }

接口里面的默认方法：
   在java 8,除了可以在接口里面写静态方法，还可以写非静态方法，但是必须default进行修饰。
   默认方法可以被继承:
   注意点：如果继承了过个父接口，有重复的默认方法被继承的子接口，必须使用super引用明确指定调用
   哪个接口的默认方法，在子接口必须要重写重复的方法，并使用下面的语法接
   <父接口类名>.super.<重复的方法名>()
  

Lambda:
  ():表示参数列表，不需要指定参数的类型，会自动推断
  ->:连接符
  {}:表示方法体
  
Lambda表达式可以认为是一种特殊匿名内部类  

Lambda语法:
 (参数列表 不需要数据类型)->{
     //执行语句
     [return....]
 }
 
 参数列表：
     1.如果形参列表是空的，只需要保留（）即可，
     2.如果没有返回值，只需要()写执行语句即可
     3.如果接口的抽象方法只有一个形参，()可以省略，只需要参数的名称即可
     4.如果执行语句只有一行，可以省略{},但是如果有返回值的时候，不可省略
     5.形参列表的数据类型自动推断，只要参数名称
     6.如果函数式接口的方法有返回值，必须要给定返回值，如果执行的代码只有一行，可以省略大括号
     7.和匿名内部类一样，如果访问的是局部变量，要求局部变量必须是final
     
     
 方法的引用：
   引用实例方法
       自动把调用方法时候的参数，全部传给引用方法
       <函数式接口><变量名>=<实例>::<实例方法名>
       //自动把实参全部传递给引用的实例方法
       <变量名>.<接口方法名>([实参])
   引用类方法：
       全部参数传给引用的方法
       <函数式接口><变量名>=<类>::<类方法名>
       //自动把[实参]全部传递给引用的类方法
       <变量名>.<接口方法名>[实参]
   引用类的实例方法:
       定义：调用接口方法的时候，需要多传一个参数，并且参数的类型和引用实例方法的类型必须一致
             把第一个参数作为引用的实例，后面的每个参数全部传递给引用的方法
              interface <函数式接口>{
               <返回值><方法名>[<类名><名称>,[其它参数]]
              }
              <函数式接口><变量名>=<类>::<实例方法名>
              <变量名>.<接口方法名>([实例方法名的类型],[实参])
   构造器引用：
       它的语法是Class::new，或者更一般的Class<T>::new
     
     
     
     

    
    
    
